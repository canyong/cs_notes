

## 用代码直接表达意图

- 用意图清晰的名字表达做什么，而不仅仅只是怎么做
- 使用表达意图的封装比直接使用语言特性要好得多
- 
```cpp
// example 1

// bad
void f()
{
    int index = -1;
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
}

// better
void f()
{
    auto p = std::find(begin(v), end(v), val);
}
```

```cpp
// example 2

// bad
change_speed(double s); // 声明
change_speed(2.3); // 调用

// better
change_speed(Speed s);
change_speed(23m / 10s); // 单位 米每秒
```

```cpp
// example 3

class Data
{
    int month(); // bad, let reader guessing
    Month month() const; // better
};
```

```cpp
//example 4

// bad
int i = 0;
while (i < v.size()) { do something whit v[i] }

// better
for (const auto& x :v) { do something with v[i] }
or
for_each(v, [](int x){ do something with v[i]}); // 使用命名算法，通过名字来表达代码意图
```

## 类型安全

- 使用静态类型安全的工具
  - variant 替代 union
  - 模板 最小化 显式类型转换
  - span 替代 数组退化、数组与数组大小分离、数组越界访问，将指针与元素数量作为一个完整对象传递
  - narrow_cast, 检查收窄类型转换
- 编译时检查优于运行时检查
  - 只有在无法编译时检查时，才进行运行时检查，对应地需要编写运行时检查及错误处理的代码

```cpp
// example 1

// bad
void read(int*p, int size);
int a[100];
read(a); // read函数并不知道数组a的大小

// better
void read(span<int> r);
int a[100];
read(a); // read在编译时已知数组a的大小
```

```cpp
// example 2

// run-time checking
int bit = 0;
do something with bit;
if (bit < 32)
    cerr << "too small\n";

// complie-time checking
static_assert(bit >= 32);
```


## C++程序设计语言回顾

    "好的工具让事情更简单、更便捷、更不易出错。"
    "让事情始终保持简单、清晰、易理解。"
    "只使用我清楚其工作原理的工具，它的行为、作用和成本，我心里有数。
     使用不了解的工具是危险的，无法预计会出现什么样的后果"

    
    c++是静态语言类型，编译器在处理任何程序实体时，必须知道它的类型，类型表明它是什么以及它能执行哪些操作

    函数返回类型为void，表示不返回任何值

    声明，定义一个名字，并指定名字实体的类型

    类型，定义一组可能的取值及一组操作

    对象，指存放某个类型值的存储空间

    值，一组二进制位，具体含义由值的类型决定

    变量， 一个命名的对象 map <变量名-内存地址>

    char类型的存储是给定机器上存储一个字符所需的空间，其他类型的尺寸则是char尺寸的整数倍，类型的实际尺寸依赖于实现

    初始化，在声明一个名字的时候已经有一个合适的值

    基本类型显式提供初始化，用户自定义类在定义时隐式初始化

    赋值号初始化，允许发生初始值到声明类型的类型转换

    初始化列表初始化，统一的初始化语法形式，可以检查类型收窄的初始化

    auto初始化，编译器从初始值推导出定义的类型，不会从初始值到推导类型结果的类型转换。
    
    /*
    有时，编译器推导出的结果类型并不是我们预期的类型，如初始化列表初始化，auto将推导为std::initializer_list类型。同时，由于值语义，auto将忽略初始值类型的const和引用修饰. auto从一个命名的程序实体或常量字面值推导结果类型
    */

    在泛型编程中，程序员很难知道对象的确切类型，并且其类型名字可能相当长，可以使用auto来避免冗余

    什么时候不用auto， 当有明显的理由时，如需要准确地控制变量的表示范围和精度(如指定float，默认为double)，或者阅读源码的人知道其类型名是非常有必要的时候

    常量，指不会发生改变的量， const运行时的常量，constexpr编译期的常量，常量因为无法被改变，因此是线程安全的.

   const，主要用于修饰接口，表示接口承诺不会改变入参的值，无需担心变量在接口函数内会改变

   constexpr，表示编译时求值，而非运行时求值，编译器将编译时求值的结果放入只读数据区。
   
   constexpr函数要求函数体只有return 语句，没有运行时语句， 调用constexpr函数的变量需要是常量，才能在编译期求值

    编译期求值的条件, constexpr函数 (常量),  如果函数体和函数入参任一不满足编译期求值要求，则转为运行期求值

    定义一个constexpr函数，得到两个函数，一个用于常量表达式，另一个用于变量

    常量表达式的概念对于 数组的界、case标签、模板实参、使用constexpr的常量是必需的


    指针， &获取变量名映射的内存地址， *对指针所指向的对象进行间接访问， 第一次访问指针变量的值，第二次访问访问指针所指向的对象

    指针解引用操作要求 指针所指向的对象必须存在且有效，因此执行解引用前需进行运行时检查，当指针指向nullptr表示没有可用的对象或对象不可用，对指向nullptr的指针解引用不会引发错误, 所有指针共享同一个nullptr对象.

    引用，类似指针，间接访问所引用的对象，但访问对象不需要进行解引用操作. 引用初始化后就无法引用其他对象(像常量指针)。

    引用更像是程序实体，其行为和程序实体相像. 不同的是，引用是间接访问到程序实体. 相当于符号链接. 结构体引用和变量都使用.运算符来访问结构体成员, 结构体指针使用->运算符来访问结构体成员

    switch的条件只能是同一类型的不同值，感觉像case枚举值, case后接常量，

    c++抽象机制的主要目的是，程序员能够设计并实现他们自己的数据类型，这些类型具有恰当的表现形式和操作，程序员可以简单优雅地使用它们.

    new运算符从一块名为自由存储(free store)或动态内存(dynamic memory)或堆(heap)的区域分配内存


    类具有一系列的成员，可能是数据、函数或类型， 类的Public成员定义了类的接口，private成员只能通过接口访问.

    c++语言处理可变数量信息的基本技术， 一个固定大小的句柄指向位于别处(new heap)的一组可变数量的数据. vector对象本身的大小永远保持不变.

    构造函数， 与类同名的函数，用于构造类的对象的函数，即初始化类的对象，可以解决类变量未初始化的问题.

    构造函数规定了类对象的构造方式，需提供要求的初始化来构造类对象

    枚举， 常用于描述规模较小的整数值集合，通过使用有意义的枚举值名字可提高代码的可读性，降低出错.

    enum class { }, class指明了是强类型的枚举，枚举值的作用域在class的作用域内，并且禁止int向枚举值的隐式转换.

    enum, 则为普通的枚举类型

    模块化， 构建c++程序的关键是清晰定义这些组成部分之间的关系。将接口和实现分离 + 使用声明来描述接口.

    声明(declaration)指定了使用某个函数或某个种类所需的所有内容.

    分离编译，一个库通常是一组分离编译的代码片段的集合。

    一般情况，将模块接口的声明放置在一个特定的文件中，文件名常常指示模块的预期用途，称为头文件.

    用户将其包含(include)进程序以访问接口.

    为保证编译一致，负责提供实现部分的文件同样应该包含同样的接口文件.

    模块化，逻辑上使用语言特性描述模块，物理上通过划分文件和分离编译充分利用模块化

    名字空间主要用于组织较大规模的程序组件，如库，使用using指示来访问名字空间中名字的访问权

    模块化和抽象机制，使运行时错误的捕获位置 和 错误处理的位置 被分离开来.

    设计并实现优雅而高效的抽象模型，如用户自定义类型和基于自定类型的算法，高层次的结构简化程序设计，减少出错的机会

    异常的设计原意是，让库的作者负责检测，并通过抛出错误(throw转移控制权)来通知调用者，而由不同错误处理方式的调用者来决定如何处理错误

    异常处理机制，使得错误处理变得简单，条理性和可读性得到增强.

    对于类，类的不变式(invariant)假定某事为真的声明，构造函数的任务是建立类的不变式，从而成员函数可以依赖于类不变式，另一个作用是确保当成员函数退出时，不变式仍然成立.

    自定义异常类，将指定的信息从检测到异常的点传递到处理异常的点.

    当异常发生时，发生异常的函数内可能就无法继续完成工作了，异常处理的含义通常是做一些简单的局部资源清理, 然后重新抛出异常














