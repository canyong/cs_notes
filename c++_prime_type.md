
## 基本程序概念

类： 一种用于定义自己的数据结构及相关操作的机制

类类型： 类定义的类型，类名即类型名

类的数据成员： 定义了类的对象的具体内容。每个对象都有自己一份数据拷贝，修改一个对象的数据成员，不会影响其他的对象
 
成员函数： 定义为类的一部分的函数， 通常通过一个类对象的名义来调用成员函数，来操作特定的对象

点运算符(.)： 左侧是类类型对象，右侧是此对象的一个成员名字

作用域运算符： 用来访问指定命名空间中的名字

std::cout： 表示我们要使用的定义在命名空间std中的名字cout

调用运算符()： 当访问成员函数时，使用调用运算符（）来调用一个函数

库类型： 标准库定义的类型

标准库： 一个类型和函数的集合

缓冲区： IO对象通常将输入/输出数据保存在一个缓冲区中，可以显式刷新缓冲区中的数据到输出设备。默认情况下，读cin会刷新cout，程序非正常终止也会刷新cout

cerr： 一个ostream对象，关联到标准错误。通常写入到与标准输出相同的设备。写cerr的数据是不缓冲的

clog：一个ostream对象，关联到标准错误，带缓冲。通常用于报告程序的执行信息，存入一个日志文件中

数据结构： 数据及其所允许操作的一种逻辑组合

数组： 是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象

string:  可变长字符串

vector: 可变长集合

变量：具名的对象

表达式： 最小的计算单元，包含一个或多个运算对象，通常还包含一个或多个运算符

函数： 用于定义可随时调用的具名计算单元

函数体： 定义了函数所执行的动作

头文件： 使定义的实体能被多个程序所使用的机制。头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。

头文件保护符(header guard)： 头文件保护符依赖于预处理变量。预处理变量有两种状态，已定义(ifdef)与未定义(ifndef)

形参列表： 函数定义的一部分，指出调用函数时可以使用什么样的实参，可为空列表

字符串常量： 0或多个字符组成的序列

#include： 头文件包含指令，使头文件中的代码可以被程序使用

静态数据类型语言： 类型检查发生在编译时，编译器必须知道每个变量对应的数据类型

C++提供扩充语言基本特征的方式： 提供自定义数据类型的机制，满足程序员各自的需求

数据类型： 告诉我们数据的意义和我们能在数据上执行的操作

静态类型语言(staticlly typed)的类型检查: 编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错且不会生成可执行文件

Unicode： 用于表示所有自然语言中字符的标准

未定义： c++语言没有明确规定的情况

可执行文件： 操作系统能直接执行的文件，包含和程序相关的代码

链接： 是一个编译过程，负责把若干对象文件链接起来形成可执行程序

对象代码： 编译器将源代码转换成对象代码格式

对象文件： 编译器根据源文件，生成保存对象代码的文件(.obj .o)


## 基本类型

大多数计算机以2^n比特作为块来处理内存，字节表示最小的可寻址单位，字表示存储的基本单位，字长由寄存器位数决定。

计算机以比特序列存储数据，类型决定了数据所占的比特数及如何解释这些比特的内容。

- 算术类型 (整数、字符、布尔、浮点数)
- 空类型 (void)

c++标准仅规定了基本数据类型的最小尺寸：
- bool 未定义
- char 8bits
- wchar_t 16bits
- char16_t unicode字符
- char32_t unicode字符
- short/int 16bits
- long 32bits
- long long 64bits
- float 6-7位有效数字
- double 15-16位有效数字

一个int至少和一个short一样大，一个long至少和int一样大，一个long long至少和long一样大。

带符号数(signed)： 表示正数、负数或0，约定表示范围正值和负值应该平衡
无符号数(unsigned)： 表示正数或0， 所有比特位都用来存储值

使用建议：
- 若已知值非负，则标明unsigned
- char在一些机器上是有符号数，一些机器上是无符号数，因此，不要在算术表达式中使用char和bool。
- long double 提供的精度一般情况下没有必要，且运行时开销不容忽视。

浮点数有效位数/精度问题： https://blog.csdn.net/dreamer2020/article/details/24158303

## 类型转换

类型转换： 将对象从一种给定的类型转换到另一种相关类型。当程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。

发生自动类型转换的场合：
- 变量初始化（定义变量、函数传参、构造函数）
- 变量赋值（按位拷贝）
- 算术计算（临时对象、类型提升）

自动转换规则：
  - others -> bool： 非0为true, 0为false
  - 负数 -> unsigned： 负数 + unsigned的模数
  - 正数 -> unsigned： 正数 % unsigned的模数
  - 整数 -> 浮点数： 整数比特位数超过浮点数位数，则可能会损失精度
  
当赋给有符号数一个超过它表示范围的值时，结果是未定义的。 程序可能工作、可能崩溃，也可能生成垃圾数据。

使用无符号数易错误的情况：
```cpp
// 死循环
for (unsigned i = 10; i >= 0; --i) { } 
 
// 计算结果为无符号数
int i = -42;
unsigned u1 = 42, unsigned u2 = 10;
std::cout << u1 + i << std::endl; // 若int占32位，输出4294967264
std::cout << u2 - u1 << std::endl;  // 输出 (-32) + unsigned的模数
```

使用建议：
- 避免无法预知和依赖于实现环境的行为
- 不要在算术计算中混用带符号类型和无符号类型

## 字面值常量

形如42的值被称为字面值常量。字面值的形式和值决定了它的数据类型。

整数字面值
- 十进制， 类型为int
- 八进制（前导0），类型为能容纳其数值的int,unsigned int,long,unsigned long,long long..
- 十六进制（前导0x），同上

```cpp
int mouth = 9, day = 7;
int mouth_ = 09, day = 07; // 八进制
```
  
浮点型字面值
(使用小数或科学计数法表示，指数部分用E或e标识，默认类型为double)
- 3.14159
- 3.14159E0
- 0.
- 0e0
- .001

字符和字符串字面值
- 'a'
- "hello world"
  
字符串字面值的类型为常量字符构成的数组，编译器在每个字符串的结尾处添加一个空字符（'\0')。

如果两个字符串字面值位置紧邻，且仅有空格、缩进和换行符分隔，则它们实际上是一个整体。
```cpp
std::cout << "a really, really long string literal "
            "that spans two lines" << std::endl;
```

转义字符： 不能被程序员直接使用的字符，通过转义来使用它们
- 不可打印字符，因为没有可视的图符
  - \n 换行 \r 回车
  - \t 横向 \v 纵向
  - \b 退格
  - \a 报警 \f 进纸
- c++语言中有特殊含义的字符
  - \\ 斜杆 \? 问号
  - \" 双引 \' 单引
  - \xxx 三位八进制数表示的字符
  - \xxxx 四位十六进制数表示的字符

指定字面值的类型
- 整型 (后缀)
  - u or U  unsigned 如 10u
  - l or L  long
  - ll or LL long long 如 42ULL
- 浮点 (后缀)
  - f or F  float 如 1E-3F
  - l or L  long double 如 3.14L
- 字符 （前缀）
  - u  char16_t
  - U  char32_t
  - L  wchar 如 L'a'
  - u8  char 如 u8"hi"
- 布尔类型
  - true
  - false
- 指针类型
  - nullptr
  
## 变量

变量提供一个具名的、可供程序操作的存储空间。每个变量都有其数据类型，数据类型决定变量所占空间大小和布局方式、能存储的值的范围以及能参与的运算。

初始化和赋值：
- { }初始化，()构造函数初始化
- 用 = 进行初始化可能会让人感到困惑
- 定义在任何函数之外的内置类型变量初始化为0
- 定义在函数体内的内置类型变量不被初始化
- 每个类各自决定其初始化对象的方式，包括是否允许不经初始化就定义对象以及默认初始值是什么

分离式编译： 允许将程序分割为若干个文件，每个文件可被独立编译

声明与定义：
- 声明，使得名字为程序所知，规定了变量的类型和名字
- 定义，除了声明部分，还创建了与名字相关的实体，可能还会为变量赋一个初始值
- 将变量声明与定义的动作分开来，为了支持分离式编译
- 多个文件使用同一个变量，该变量被定义一次，被声明多次
- 使用 extern 标示要引用的外部变量，否则即为本文件定义的变量

```cpp
extern int i; // 声明，使用include指令包含定义变量i的文件
int j; // 声明并定义了变量j
extern double pi = 3.14159; // 定义，初始化抵消extern
```

## 标识符

每个标识符/名字(identifier)都会指向一个特定的实体，可以是变量、函数、类型等。

c++标准库保留的标识符：
- 以连续两个下划线开头
- 以下划线+大写字母开头

作用域(scope)： 在其中的名字有特定的含义。
- 若同一个名字如果出现在程序的不同位置，可能指向不同的实体
- 全局作用域： 名字在整个程序范围内都可使用，定义在main函数之外和类之外
- 块作用域： 名字仅在使用花括号定义的块作用域内可使用
- 嵌套作用域： 内层作用域可以访问到外层作用域定义的名字，内层作用域也可以重新定义该名字的含义

```cpp
#include <iostream>
 
int reused = 42;
int main() {
    int unique = 0; // block scope
    int reused = 0; // redefine
    std::cout << ::reused << std::endl; // 42
}
```

## 复合类型

声明语句 = 基本类型 + 声明符号 + 变量名。声明符命名一个变量并指定了变量为与基本类型相关的某种更复杂的类型。

引用：
- 为变量起另一个名字，本身非对象，不能定义引用的引用（二级引用)和指向引用的指针
- 定义引用时，编译器将其和它引用的变量绑定在一起
- 对引用进行的所有操作都是在与之绑定的变量上进行
- 引用类型须与绑定的变量的类型一致，不会发生自动类型
- 左值引用只能绑定到变量上，不能绑定到字面值、临时对象
- 
- 本身非变量，只是一个标识符(声明)，不能对其取地址、不能定义二级引用和引用的指针
- 引用名关联到一个变量，通过引用名读写关联的变量，无需进行解引用操作
- 引用的生命周期比关联变量的生命周期短，不会出现非法内存访问的情况
- 使用引用，其实是使用引用的对象
  
```cpp
int i = 0;
int & ref = i;
ref = 1; // i = 1
int j = ref; // j = i
```

指针：
- 本身是个对象，能对指针进行拷贝操作
- 可以不必初始化，生命周期内可改变指向关系
- 指针的类型要与它指向的对象类型一致，不会发生自动类型转换
- 可以定义指向指针的引用
- 
- 本身是变量(定义)，可以对其取地址，能定义二级指针和指针的引用
- 指针的值指向一个变量，通过指针读写指向的变量，需先进行指针的解引用操作
- 指针的生命周期可能比所指向的变量的生命周期长，可能会出现非法内存访问的情况

```cpp
int i = 0;
int *p = &i; // operator&
*p = 1; // operator*
int *&ref = p; // define a reference that refers to int*
```

指针值的状态：
- 指向一个对象
- 指向紧邻对象的下一个位置
- 没有指向任何对象，空指针
- 除上述情况之外，无效指针
- 
- 指向有效地址
    - 指向一个类型相符的对象
    - 指向本对象的下一个对象（循环结束的下一个指针位置++）
    - 指向空（地址0）
- 指向无效地址

只有第一种情况可以安全的使用operator*，解引用操作。

相同类型的指针可以进行值比较，当相等时的情况
- 都指向同一对象
- 都指向空
- 一个指向本对象的下一对象

void*指针
- 存取保存的地址
- 和同类型指针比较保存的地址
- 作为函数的输入或输出

## const

const类型的对象无法执行修改内容的操作，其他与常规类型相同。

const初始化：
- 可以运行时初始化
- 编译时初始化，编译器用数值替换const变量
- 默认情况，const仅在文件内有效，跨文件需extern，指明并非本文件所独有，它的定义在别处

```cpp
// file_1.cc 
extern const int buff_size = get_size();

// file_1.h
extern const int buff_size;
```

const引用：
- 可能引用到非const对象，无法阻止非const对象以其他途径被修改
- 初始化常量引用时，允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型
- 使用const引用，意图不会通过引用来改变被引用对象的值，所以可以绑定到字面值和临时对象上

```cpp
int i = 0;
const int & ref = 0;
const int & ref_ = 2 * i;
```

临时量对象： 当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象

当const引用绑定到不同类型的对象时：
```cpp
double pi = 3.14159;
const int & ref = pi;

// 等价于 ref 绑定到一个临时量，无法通过引用改变临时量的值

const int temp = pi;
const int & ref = temp;
```

const指针：
- 顶层const， 修饰所定义的对象本身，可以表示任意的对象是常量，如算术类型、类、指针等
- 底层const， 修饰所定义的指针对象指向的对象，与复合类型的基本类型部分有关
- 顶层const，存在被忽略掉的情况

```cpp
int i = 0;
const int ci = 0; // 顶层const
int *const p1 = &i; // 定义一个const p1指针，指向int类型，顶层const
const int *p2 = &i; // 定义一个p2指针，指向const int类型，底层const
int *p3 = p2; // error，底层cosnt的限制无法被忽视
i = *p2; //ok，拷贝操作，顶层const的限制可以被忽视
```

常量表达式：指值不会改变并且编译过程就能得到计算结果的表达式

constexpr类型：
- 将变量声明为constexpr类型以便由编译器来验证变量是否为常量表达式
- 声明为constexpr的变量是一个常量，需要用常量表达式初始化
- 常量表达式有字面值、全局变量、constexpr函数、constexpr变量
- 当确定const变量是常量时，可以使用constexpr替代
- constexpr仅对指针有效，与指针所指对象无关
- constexpr指针仅能指向全局变量

```cpp
const int *p = nullptr;
constexpr int *q = nullptr; // 常量指针

// 指向固定地址的变量
const int i = 0;
int j = 0;
int main() {
    constexpr const int * p = &i;
    constexpr int * q = &j;
}
```

## 类型别名

类型别名(type alias)，某种类型的同义词，让复杂的类型名字变得更加易于理解和使用。

使用建议：
- 避免使用类型别名指代符合类型和常量，容易出错
```cpp
typedef char* pstring;
const pstring cstr = 0; // 常量指针，const修饰pstring，类似const int
const pstring *ps; // 二级指针，非一级指针
```

## auto 类型说明符

编程时，常常需要把表达式的值赋给变量，这就要求在声明变量时清楚地知道表达式的类型。而有时清楚表达式的类型却是不易的。使用auto，让编译器去帮助我们分析表达式所属的类型。编译器通过初始值(表达式)来推断变量的类型。

auto推导规则：
- 忽略初始值的顶层const，当引用/指针用作初始值时，真正参与初始化的是对象的值
- 保留初始值的底层const，当在复合类型中，auto 推导出 const
- 若希望auto推导出顶层const，则在左侧明确指出
- 若希望auto推导出引用或指针类型，则在左侧明确指出
- 左侧明确指出引用，保留顶层const
```cpp
const int ci = 0;

auto i = ci; // int，拷贝操作，顶层const不受影响
auto p = &ci; // cosnt int *p，对常量对象取地址为底层const

const auto cii = ci; // auto->int, cii->const int 
auto &ref = ci; // auto->cosnt int, ref->const int &
auto &error = 0; // auto->int, error->int &
cosnt auto &ref_ = 0; // auto->int, ref_->const int &
```

## decltype 类型指示符

decltype从表达式推断出类型：
- 表达式是函数调用，不调用函数，直接读取函数的返回值类型声明
- 表达式是变量(值），返回变量的完整类型
- 表达式为算术表达式，则返回计算结果的类型
- 表达式返回左值，则返回对应类型的引用
  - 指针解引用操作
  - (var) 括号表达式
  - operator[]
  - operator=

```cpp
const int ci = 0;
const int &cj = ci;
decltype(ci) cii = 0; // const int
decltype(cj) ref = ci; // const int &
decltype(cj + 0) ciii = 0; // int 

const int *p = &ci;
decltype(*p) ref_ = ci; // cosnt int &
decltype((ci)) reff_= ci; // const int &
```

