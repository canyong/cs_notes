
## 概念

表达式： 
- 由一个或多个运算对象（operand)组成，对表达式求值将得到一个结果
- 字面值和变量是最简单的表达式，其结果就是字面值和变量的值
- 把一个运算符(operator)和一个或多个运算对象组合起来就可以较复杂的表达式

运算符：
- 一元运算符 1个运算对象
- 二元运算符 2个运算对象
- 三元运算符 3个运算对象
- 函数调用运算符 不限制运算对象

组合运算符和运算对象：
- 优先级(precedence)：用于判断有多个 不同优先级 的运算符的执行顺序
- 结合律(associativity)：用于判断多个 同一优先级 的运算符的执行顺序

运算对象的求值顺序(order of evaluation):
- 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值，c++语言并没有规定大多数的二元运算符的求值顺序
- 4种规定了运算对象求值顺序的运算符：逻辑与、逻辑或、条件运算符、逗号运算符

子表达式的求值顺序：
- 复杂表达式含有多个运算符对象和运算符，哪个子表达式先求值哪个后求值，由运算符来决定
- 运算对象先和优先级高的运算符进行组合，当表达式中所有运算符的优先级相同时，由运算符的结合律规定，从左到右的或从右到左的方向，依次对子表达式进行求值
- 运算符的优先级和结合律规定了子表达式的求值顺序，但对于有多个运算对象的运算符，哪个运算对象先哪个运算对象后却无规定。如二元运算符，a + b, 先读a还是先读b并无确定顺序
- 当二元运算符的两个运算对象是同一个变量，一个运算对象是对读值，一个运算对象写值，由于求值顺序不定，先读后写还是先写后读是未定的
- 当二元运算符的两个运算对象是同一个I/O对象时，一个运算对象读I/O，一个运算对象写I/O，如 read () + write()，可能的结果为读的是刚写入的内容或者读的是旧的内容

```cpp
int i = f1() * f2(); // f1 和 f2 调用顺序未定，如果f1和f2没有修改状态的行为(写)，则安全，调用顺序无关紧要。否则，将产生未定义的行为

int i = 0;
cout <<ｉ << ++i << endl; // i 和 ++i 求值顺序未定，程序是未定义的，无法推断它的行为 ??
                         // 求值结果有无可能是 1 1 ??

*++iter; // ++iter是*的子表达式，求*前须先求++
```

运算对象类型转换：当二元运算符的两个对象类型不同时，只要它们能够转换到同一类型即可
- int -> double
- double -> int
- int -> long long

重载运算符(overload operator)： 为已存在的运算符赋予另一层含义。重载运算符无法改变运算对象的个数、运算符的优先级和结合律。只能改变运算对象的类型和返回值的类型

左值和右值：
- 赋值语句左侧运算对象为左值，右侧运算对象为右值
- 左值是可以作为赋值语句左侧的运算对象
- 右值是可以作为赋值语句右侧的运算对象
- 一个表达式，可以即使左值也是右值
- 当对象被用作左值时，用的是对象的内存位置。当对象作为右值时，用的是对象的值
- 需要右值的地方，可以使用左值替代。但需要左值的地方，不能将右值当作左值使用
- 右值的例子
  - 字面值
  - 常量表达式
  - operator& 的返回值
  - 编译器产生临时对象
    - 类型转换
      - 初始化语句
      - 赋值语句
    - 算术表达式的中间结果
    - 函数值返回
  - new生成的匿名对象
- 左值的例子
  - operator= 的返回值
  - operator[] 的返回值
  - operator* 的返回值
  - decltype(lvalue) 返回值

左值转为右值的方法：
- std::move，将左值类型转为右值类型
- std::forward，返回值有两种情况，若返回值为左值，则返回左值。否则实现move的功能

右值转左值的方法：
- 右值引用，将右值引用绑定到右值
- 命名指针，指向new出来的匿名对象

## 算术运算符

作用于算术类型的运算对象，或任何能转换为算术类型的类型。运算符的运算对象和返回值均为右值。

一元正号和负号: 作用于基本类型，小于int的类型(bool、char、short)，提升为int. 符号返回负值
```cpp
// 布尔类型不应该参与算术运算
bool b = true;
bool b1 = -b; // -b->(-1), b1->true 
```

除法(商)和取模(余数):
- 整数相除还是整数，丢弃商含有小数的部分，结果向数轴0的方向取整
- 数学定义规定，被除数不能是0
- 取余为计算两个整数相除后的余数，当负整数取余的情况
  - (-m) % n <==> -(m % n)
  - m % (-n) <==> m % n

算术结果溢出： 计算结果超过类型所能表示的数值范围，发生溢出的一种可能结果是环绕(wrapped around)
```cpp
short var = 32767;
std::cout << ++var << std::endl; // -32768
```

<climits>定义的带符号整数的数值表示范围：

```cpp
std::cout << CHAR_MIN << " " << CHAR_MAX << std::endl;
std::cout << SHRT_MIN << " " << SHRT_MAX << std::endl;
std::cout << INT_MIN << " " << INT_MAX << std::endl;
std::cout << LONG_MIN << " " << LONG_MAX << std::endl;
std::cout << LONG_LONG_MIN << " " << LONG_LONG_MAX << std::endl;

-128 127 (1 Bytes)
-32768 32,767 (2 Bytes)
-2147483648 2,147,483,647 (4 Bytes)
-9223372036854775808 9,223,372,036,854,775,807 (8 Bytes)
-9223372036854775808 9223372036854775807
```

## 逻辑和关系运算符

关系运算符:
- 运算对象是算术类型和指针类型，求值结果为布尔类型
- 优先级: 大小关系 > 相等不等关系
- 错误地使用
  - if (i < j < k)
  - if (i == true)， 如果想知道i是否为1，应该写 if(i == 1)
  
逻辑运算符：
- 运算对象是布尔类型或能转为布尔类型的类型，求值结果为布尔类型
- 优先级: ! > && > ||
- 逻辑与表示所有都要满足。左结合，当左侧对象为真时，才对右侧运算对象求值
- 逻辑或表示只要存在一个满足，左结合，当左侧运算对象为假时，才对右侧运算对象求值
- 逻辑非，将布尔类型的值取反，true->false, false->true
- 利用逻辑运算符的短路求值(short-circuit evaluation)来检查索引位置的有效性

```cpp
// 当Index未到end(str)，才计算str[index]
index != str.size() && !isspace(str[index]); 

// 输出text的内容，当遇到空字符串或句号结束的字符串时进行换行
for (const auto & s : text) {
    cout << s;
    if (s.empty() || s[s.size() - 1] == '.')
        cout << endl;
    else
        cout << " ";
}
```
## 赋值运算符

- 拷贝同类对象的值，替换掉自身的旧值
- 赋值运算符的左侧运算对象必须是一个可修改的左值，求值结果为左侧运算对象它自己，右结合
- 若左侧对象和右侧对象的类型不一致，则将右侧对象转换为左侧对象的类型
- 初始值列表{ }可以作为右侧的运算对象，使用列表内的值逐一替换旧值
- 无论左侧运算对象是什么类型，初始化列表{ }为空时，编译器自动使用默认值赋给左侧运算对象
- 若右侧运算对象发生类型收窄转换，可能会丢失精度。使用{ }进行赋值，可以检测到类型收窄并编译报错
- 若右侧运算对象的初始值列表{ }内的值过多，会产生编译报错
- 赋值运算符优先级较低，比逻辑运算符还要低，注意用括号来使操作符合我们的原意

```cpp
int i, j;
double pi = 3.14159;

i = j = {pi}; // warning
i = j = {3.14159}; // error
i = j = 3.14159; // 通过

while ((i = get_value()) != 42)
    i = get_value();

while (i = j) ++i; // 误用赋值表达式作为条件
```

复合赋值运算符： a = a op b, 用于需要对对象施以某一运算，然后把计算结果再赋给该对象
- 左侧对象只被求值一次，普通运算符求值两次(读两次内存)
- 算术运算符： +=、 -=、 *=、 /=、 %=
- 位运算符：  <<=、>>=、 &=、 ^=、 |= 

## 递增递减运算符

- 为加1减1提供了简洁的书写形式
- 前置版本的++，表示使用++后的对象，运算对象为可修改的左值，求值结果为新值
- 后置版本的++，表示使用++前的对象并加1，运算对象为可修改的左值，求值结果为旧值
- 当需要使用到对象原来的值，并且对对象++时，使用后置版本。其余情况，使用前置版本
- 解引用运算符*和++混用时，++优先级高

```cpp
//  简洁写法
auto begin = v.begin();
while (begin != v.end() && *begin >= 0)
    std::cout << *begin++; // 输出然后向前移动

// 错误写法
auto begin = str.begin();
while (begin != str.end() && !isspace(*begin))
    *beg = toupper(*beg++); // 赋值表达式左右运算对象求值顺序未定，程序结果将未定义
                            // 一种可能的结果是错位赋值，将本字符赋值给下一个位置

// 表达式的含义以及是否有错 ?
user++ = x.user // error，++优先级大于=,user++将返回右值，赋值失败
ptr != 0 && *ptr++  //ok 
ival++ && ival // ok
vec[ival++] <= vec[ival] // error, 关系运算符两侧的运算对象求值顺序不确定，结果不确定

```

## 成员访问运算符

- 点运算符： 作用于一个对象，若成员所属的对象是左值，求值结果就为左值，否则为右值 ??
- 箭头运算符：运算对象为指针类型，求值结果为左值

n = (*p).size(); // 点运算符优先级大于解引用运算符
n = p->size();   // 等价于上式， 箭头运算符集合了解引用和点运算符两个操作

```cpp
// 表达式的含义以及是否有错 ?
*iter++ vs ++*iter  // ok
iter++->empty(()  //  iter->empty();  iter++;
```

## 条件运算符

- 允许把简单的if-self逻辑嵌入到单个表达式当中
- cond ? expr1 : expr2, 条件运算符只对expr1或expr2其中一个求值
- 当条件运算符的两个表达式都是左值或能转换成同一种类型时，运算结果是左值，否则是右值
- 条件运算符可以嵌套，嵌套层数不宜超过2-3层
- 条件运算符的优先级很低，比输出运算符 << 低，留心用括号表示正确求值顺序
- 条件运算符右结合律，靠右的条件运算(嵌套表达式)构成了靠左边的条件运算的分支
  
```cpp
// 
string final_grade = (grade > 90) ? "high pass"
                                    : (grade < 60) ? "fail" : "pass";

cout << ((grade < 60) ? "fail" : "pass"); // ok.
cout << (grade < 60) ? "fail" : "pass"; // erro, 输出0或1. cout ? "fail" : "pass";
cout << grade < 60 ? "fail" : "pass"; // cout << grade;
                                      // cout < 60 ? "fail" : "pass";
```

## 位运算符

- 作用于整数类型，把运算对看成是二进制位的集合
- 优先级： ~ > <<、>> > & > ^ > |
- 有符号数的符号位处理依赖于具体的机器实现，建议将位运算用于无符号数
- 小整型在位运算时会被提升为int
- 通过将一个运算对象(掩码)与另一个对象进行位与、位或、位异或来实现修改值
- 位或，用于将某个二进制位置1，掩码1
- 位与，用于将某个二进制位置0，掩码~1 用于测试某个位是否为1，掩码1
- 位异或，有且仅有一个1，则为1，满足交换律和结合律，用途 ??
- 以上三种不同的运算方式，结合恰当掩码，都可以实现相同的计算结果 ??
- 移位运算符被I/O流库重载为输入和输出运算符，重新赋予另一层含义
- 移位运算符优先级比算术低，比关系、赋值、条件高，左结合，留心添加括号规定求值顺序
- 移位运算时，留心移位溢出问题，溢出位舍弃
- 位运算，用来实现更高级的算术运算

```cpp
// 位运算
unsigned char bits = 0;
unsigned char mask = 1;
bits |= mask << 7; // 使用 1000 0000 位或 bits.
bits &= ~(mask << 7); // 使用 0111 1111 位与 bits，取消上一步的操作效果
bool status = bits & (mask << 7); // 检查第8个(索引为7)二进制位的值, false

// 遍历二进制位集合
for (int i = 0; i < 8; ++i) {
	bool status = (bits & 128UL >> i);
	std::cout << status;
}

// 移位运算符
((cout << "hi") << "there") << endl; // hi与第一个<<结合，其求值结果与第二个<<结合

cout << 10 < 42; // 等价于 (cout << 10) < 42; 第一个表达式返回cout，然后将cout与42进行比较，因cout没有定义operator<，编译报错 

// 神奇的两个数
unsigned long ul1 = 3, ul2 = 7;
ul1 & ul2 = 3
ul1 | ul2 = 7
```

## 机器数的编码方式

机器数： 一个数在计算机中的二进制形式，称为机器数。对于符号数，机器数的最高位比特作为符号位，其他比特作为数据位

真值： 将机器数对应的数值称为机器数的真值 (十进制表示)

有三种编码方式可以将真值转为为机器数：
- 原码，即真值的二进制表示，不支持负数的算术运算
- 反码，将原码的数值位按位取反，支持负数的算术运算，但存在+0和-0两个值的机器数表示
- 补码，将反码的最低位加1，支持符号位参与算术运算，只有一个0，即+0，空出的-0位置用来表示最小值
- 补码实现符号位也参与运算的方法是，取负数的同余数(正数)替代负数，让减法变加法运算
- 正数的三码表示形式相同，负数的三码表示形式不同
- 计算机用补码的编码方式来表示机器数
- 大脑可以直接读出真值的是原码，反码和补码转为原码，再读出机器数的真值
- ~(补码 - 1) = 原码
  
数字(-3)的机器数表示:
- 原码: 1000 0011
- 反码: 1111 1100
- 补码: 1111 1101

数字7的机器数表示：
- 原码: 0000 0111
- 反码: 0111 1000
- 补码: 0111 1001

参考链接： https://zhuanlan.zhihu.com/p/91967268

## sizeof运算符

- sizeof(type)
- sizeof expr
- 运算对象为类型或表达式，求值结果为用一个size_t类型的常量表达式表示类型所占的内存空间
- 优先级同解引用运算符*，右结合，留心给expr加括号 
- sizeof 并不对表达式进行计算
- 常见情况
  - sizeof 数组名，返回 数组的大小
  - sizeof *指针，返回指针所指向对的大小，若指向数组，则返回数组第一个元素的大小
  - sizeof 引用，返回所引用的对象的大小
  - sizeof vector对象，返回类型固定部分的大小，不含动态内存分配部分

```cpp
Sale_data data;
sizeof data.revenue;
sizeof Sale_data::revenue; // static成员

std::cout << sizeof (a + b); // 留心优先级，加括号

// 计算数组元素个数
constexpr size_t sz = sizeof(arr) / sizeof(*arr);
```

## 逗号运算符

- 运算对象从左到右求值，先对左表达式求值，然后将求值结果丢弃
- 返回右侧运算对象的求值结果，可能是左值或右值

```cpp
some_value ? ++x, ++y : --x, --y;
```

## 类型转换

如果两种类型关联，当程序需要其中一种类型运算对象时，可以用另一种相关类型的对象或值来替代，即这两种类型可以相互转换

隐式类型转换(implicit conversion)：
- 什么情况发生
  - 小整数到大整数的提升，整型提升(interal promotion)
  - 条件表达式中，其他类型转布尔类型
  - 初始化变量，初始值转为变量的类型。赋值运算符右侧对象转为左侧对象类型
  - 算术运算或关系运算，运算对象类型不一致
    - 有符号数和无符号数
      - 若带符号类型内存空间大于无符号类型，可能将无符号转为有符号。反之，转为无符号类型
- 有哪些隐式类型转换的例子
  - 字面值转类型
  - 数组转指针
  - 指针转void*
  - non-const 转 const

```cpp
// 转布尔类型
char *cp = get_string();
if (cp) { ... } 

while (cin>>s) { ... }
```

显式类型转换：
- 命名的强制类型转换
  - cast-name<type>(exprssion)
    - static_cast，转为不同的类型
    - const_cast，去除底层const修饰，底层const修饰对象元素，顶层const修饰指针引用
    - reinterpret_cast ? 以其他指针类型访问内容??
- 旧式类型转换
  - (type) expr

```cpp
double result = static_cast<double>(j) / i; // 浮点数运算, i,j属于int

void *p = &d;
double *dp = static_cast<double*>(p); // void*转回原来的指针类型

const char *pc;
char *p = const_cast<char*>(pc); // 若pc指向常量字符串，获取写入权限进行写入将产生未定义后果
```

使用建议：
- 避免使用强制类型转换，其干扰了正常的类型检查。如无法避免，尽量限制类型转换值的作用域
- 使用命名类型转换，更加清晰
  
